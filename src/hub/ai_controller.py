"""
AI-IoT Hub Main Controller with LLM Integration

This is the main interface that uses smolagents to understand user requests,
generate device communication code, and execute commands on IoT devices.
"""

import asyncio
import json
import logging
from pathlib import Path
from typing import Dict, Any, Optional
import yaml

from smolagents import CodeAgent, InferenceClientModel
from agents.spec_analyzer import SpecAnalyzer
from agents.device_tools import DeviceDiscoveryTool, DeviceControlTool, CredentialManagerTool

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AIIoTHubController:
    """Main AI-IoT Hub controller with LLM-powered device communication"""
    
    def __init__(self, config_path: str = "config/hub_config.yaml"):
        self.config_path = Path(config_path)
        self.config = self._load_config()
        
        # Initialize LLM model
        self.model = InferenceClientModel(
            model_id=self.config.get('model', {}).get('model_id', 'meta-llama/Meta-Llama-3.1-8B-Instruct')
        )
        
        # Initialize agents and tools
        self.spec_analyzer = SpecAnalyzer()
        self.device_discovery = DeviceDiscoveryTool()
        self.device_control = DeviceControlTool()
        self.credential_manager = CredentialManagerTool()
        
        # Initialize main LLM agent with tools
        self.agent = CodeAgent(
            tools=[
                self.device_discovery,
                self.device_control, 
                self.credential_manager
            ],
            model=self.model,
            additional_authorized_imports=[
                'requests', 'socket', 'asyncio', 'json', 'time',
                'paho.mqtt.client', 'pymodbus.client', 'websockets',
                'yaml', 'pathlib', 'importlib.util'
            ],
            instructions=self._create_system_instructions()
        )
        
    def _load_config(self) -> Dict[str, Any]:
        """Load hub configuration"""
        if self.config_path.exists():
            with open(self.config_path) as f:
                return yaml.safe_load(f)
        else:
            # Default config
            default_config = {
                'model': {
                    'model_id': 'meta-llama/Meta-Llama-3.1-8B-Instruct',
                    'temperature': 0.1
                },
                'credentials': {},
                'devices': {},
                'cache_ttl': 3600
            }
            self.config_path.parent.mkdir(parents=True, exist_ok=True)
            with open(self.config_path, 'w') as f:
                yaml.dump(default_config, f, indent=2)
            return default_config
    
    def _create_system_instructions(self) -> str:
        """Create comprehensive system instructions for the LLM agent"""
        return """
You are the AI-IoT Hub Controller, an intelligent system that helps users communicate with and control IoT devices on their network.

## Your Role & Capabilities

You help users:
1. **Discover devices** on the network (IP addresses, device types)
2. **Generate communication code** from device documentation  
3. **Execute device commands** using generated or cached tools
4. **Handle credentials** securely for device authentication

## File Structure Understanding

**Raw Documentation** (`devices/raw_docs/{category}/`):
- PDFs, Word docs, URLs in .txt files with device API specifications
- Examples: `samsung_smartthings_api.txt`, `honeywell_manual.pdf`
- YOU read these to understand device protocols and capabilities

**Generated Specs** (`devices/generated_specs/`):
- JSON files with structured device specifications you create
- Contains: endpoints, authentication, protocols, capabilities
- Generated by parsing raw documentation

**Generated Tools** (`tools/generated/`):
- Python communication modules you create for specific device+IP combinations
- Named: `{device_type}_{ip_with_underscores}.py` 
- Contains: DeviceCommunicator class with connect/disconnect/command methods

**Configuration** (`config/`):
- `hub_config.yaml`: Main config with credentials, device registry
- Store API tokens, passwords, device IDs here securely

## Communication Protocols Supported

- **REST API**: HTTP requests with authentication (SmartThings, Nest, etc.)
- **TCP Sockets**: Raw TCP or protocol-specific (Modbus TCP)
- **MQTT**: Publish/subscribe messaging
- **WebSockets**: Real-time bidirectional communication

## Workflow for Device Communication

1. **Check for existing tool**: Look in `tools/generated/` for `{device_type}_{ip}.py`
2. **If no tool exists**:
   - Find device docs in `devices/raw_docs/`
   - Parse documentation into structured spec
   - Generate Python communication code
   - Save as `tools/generated/{device_type}_{ip}.py`
3. **Import and use tool**: Load the DeviceCommunicator class and execute commands
4. **Handle credentials**: Prompt user for tokens/passwords if not in config

## Credential Management

When devices need authentication:
- **Check config first**: Look in `config/hub_config.yaml` under `credentials`
- **Prompt user if missing**: Ask for API tokens, passwords, device IDs
- **Store securely**: Save to config file for future use
- **Common credential types**:
  - SmartThings: Personal Access Token (PAT) + Device ID
  - Modbus: Usually none (direct IP connection)
  - MQTT: Username/password + broker address
  - Custom APIs: API keys, bearer tokens

## Example User Interactions

**"Turn on the washing machine at 192.168.0.5"**
â†’ Check for `washing_machine_192_168_0_5.py` tool
â†’ If not found, generate from SmartThings API docs
â†’ Prompt for SmartThings PAT token if needed
â†’ Execute start_wash_cycle() command

**"Check temperature from sensor at 192.168.1.50"**  
â†’ Look for sensor communication tool
â†’ Generate from Modbus/TCP docs if needed
â†’ Connect via TCP socket and read temperature register

**"Discover all devices on network"**
â†’ Scan IP range from config (192.168.1.0/24)
â†’ Identify device types and update device registry
â†’ Report findings to user

## Response Format

Always provide:
1. **Status**: What you're doing (discovering, generating, communicating)
2. **Credentials needed**: Prompt for missing authentication
3. **Results**: Actual device responses or error messages
4. **Files created**: Note any new specs or tools generated

Be conversational but technical. Explain what protocols you're using and why.
"""

    async def process_user_request(self, user_message: str) -> str:
        """Process user request using LLM agent"""
        
        logger.info(f"Processing user request: {user_message}")
        
        # Add context about current system state to the message
        context_message = f"""
User Request: {user_message}

Current System Context:
- Available raw documentation: {self._list_available_docs()}
- Generated specs: {self._list_generated_specs()}  
- Cached tools: {self._list_cached_tools()}
- Configured devices: {list(self.config.get('devices', {}).keys())}
- Available credentials: {list(self.config.get('credentials', {}).keys())}

Please analyze this request and take appropriate action to help the user communicate with their IoT devices.
"""
        
        try:
            # Use CodeAgent to process the request
            response = self.agent.run(context_message)
            
            logger.info("Request processed successfully")
            return response
            
        except Exception as e:
            error_msg = f"Error processing request: {e}"
            logger.error(error_msg)
            return error_msg
    
    def _list_available_docs(self) -> list:
        """List available raw documentation files"""
        docs_path = Path("devices/raw_docs")
        if not docs_path.exists():
            return []
        
        docs = []
        for category_dir in docs_path.iterdir():
            if category_dir.is_dir():
                for doc_file in category_dir.iterdir():
                    docs.append(f"{category_dir.name}/{doc_file.name}")
        return docs
    
    def _list_generated_specs(self) -> list:
        """List generated specification files"""
        specs_path = Path("devices/generated_specs")
        if not specs_path.exists():
            return []
        
        return [f.name for f in specs_path.iterdir() if f.suffix == '.json']
    
    def _list_cached_tools(self) -> list:
        """List cached communication tools"""
        tools_path = Path("tools/generated")
        if not tools_path.exists():
            return []
        
        return [f.name for f in tools_path.iterdir() if f.suffix == '.py']
    
    async def interactive_mode(self):
        """Run interactive chat mode with the user"""
        print("ðŸš€ AI-IoT Hub Controller")
        print("=" * 50)
        print("I can help you communicate with IoT devices on your network.")
        print("Ask me to discover devices, check status, or control equipment.")
        print("Type 'quit' to exit.\n")
        
        while True:
            try:
                user_input = input("You: ").strip()
                
                if user_input.lower() in ['quit', 'exit', 'q']:
                    print("Goodbye! ðŸ‘‹")
                    break
                
                if not user_input:
                    continue
                
                print("AI-IoT Hub: Processing your request...")
                response = await self.process_user_request(user_input)
                print(f"AI-IoT Hub: {response}\n")
                
            except KeyboardInterrupt:
                print("\nGoodbye! ðŸ‘‹")
                break
            except Exception as e:
                print(f"Error: {e}\n")

async def main():
    """Main entry point"""
    hub = AIIoTHubController()
    await hub.interactive_mode()

if __name__ == "__main__":
    asyncio.run(main())